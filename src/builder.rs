use async_lsp::lsp_types::Url as Uri;
use derive_more::Constructor;
use std::collections::HashSet;

use crate::types::SourceHash;

use options_builder::BuildOptions;
pub use options_builder::BuildOptionsBuilder;
use source_map_builder::SourceMapBuilder;

use emit::{Context, Emit, EmitResult};

mod emit;
mod forwarding;
mod options_builder;
mod source_map_builder;

pub const EMIT_FILE_EXT: &str = ".emitted";

#[derive(Debug, Constructor)]
pub struct Build {
    pub content: String,
    pub uri: Uri,

    source_map: sourcemap::SourceMap,
    tokens_count: usize,
}

type PatternSources = HashSet<SourceHash>;

impl Build {
    pub fn create(mut opt_builder: BuildOptionsBuilder) -> anyhow::Result<Self> {
        if opt_builder.options.pat.is_none() {
            return build(&opt_builder.options).map(|s| s.0);
        }

        let pat_source = opt_builder.options.pat.as_ref().unwrap().source;
        let (_, pat_sources) = build(&opt_builder.options)?;

        if !pat_sources.as_ref().unwrap().contains(&pat_source) {
            let msg = "build does not contain desired source pattern";
            return Err(anyhow::Error::msg(msg));
        }

        opt_builder.options.pat_sources = pat_sources;
        opt_builder.options.pat = None;

        let (build_with_tree_shaking, _) = build(&opt_builder.options)?;
        let sources = &build_with_tree_shaking.sources();

        debug_assert!(sources.iter().any(|s| SourceHash::new(s) == pat_source));

        Ok(build_with_tree_shaking)
    }
}

fn build(opt: &BuildOptions) -> anyhow::Result<(Build, Option<PatternSources>)> {
    let doc = opt.st.get_doc(opt.uri)?;
    let (mut initial_buf, sources_cap, tokens_cap) = {
        match &opt.pb {
            Some(b) => (
                String::with_capacity(b.content.len()),
                b.sources().len(),
                b.tokens_count,
            ),
            None => (String::new(), 0, 0),
        }
    };

    if opt.resolve_deps {
        initial_buf.push_str("/** DO NOT EDIT THIS FILE. Build of '");
        initial_buf.push_str(&doc.source);
        initial_buf.push_str("' with sourcemaps ");
        initial_buf.push_str("https://evanw.github.io/source-map-visualization/ ");
        initial_buf.push_str("by glscript-language-server */\n");
    }

    let default_doc = &opt.st.get_default_doc();
    let new_ctx = || {
        let visited = HashSet::<SourceHash>::with_capacity(sources_cap);
        let (p, s, i) = (opt.pat.clone(), opt.pat_sources.clone(), opt.resolve_deps);
        Context::new(opt.st, default_doc, visited, p, s, i, false)
    };

    {
        let builder = SourceMapBuilder::with_capacity(tokens_cap, sources_cap);
        let dst_line = if opt.resolve_deps { 1 } else { 0 };
        let mut emit_state = Emit::WithSourceMapBuilderAndDstLine(builder, dst_line);
        Emit::prepare_par_iter(&mut emit_state, &mut new_ctx(), opt.uri);
        emit_state.finish(opt.st);
    }

    let sourcemap_task = || {
        let builder = SourceMapBuilder::with_capacity(tokens_cap, sources_cap);
        let dst_line = if opt.resolve_deps { 1 } else { 0 };
        let mut emit_sourcemap_state = Emit::WithSourceMapBuilderAndDstLine(builder, dst_line);
        Emit::sourcemap(&mut emit_sourcemap_state, &mut new_ctx(), opt.uri);
        match emit_sourcemap_state.finish(opt.st) {
            EmitResult::TokensCountAndSourceMap(count, sm) => (count, sm),
            _ => unreachable!(),
        }
    };
    let content_task = || {
        let pat_sources = opt.pat.as_ref().map(|_| HashSet::default());
        let mut emit_st = Emit::WithDstContent(initial_buf, pat_sources);
        Emit::content(&mut emit_st, &mut new_ctx(), opt.uri);
        match emit_st.finish(opt.st) {
            EmitResult::Content(content, pat_sources) => (content, pat_sources),
            _ => unreachable!(),
        }
    };

    let ((tokens_count, source_map), (content, pattern_sources)) =
        rayon::join(sourcemap_task, content_task); // TODO: rebuild only sourcemap on dep_hash eq prev

    #[cfg(debug_assertions)]
    emit::emit_on_disk(opt, &doc, &source_map, &content)?;

    let emit_uri = match opt.resolve_deps {
        true => doc.bundle_uri.as_ref().clone(),
        false => doc.transpile_uri.as_ref().clone(),
    };

    let build = Build::new(content, emit_uri, source_map, tokens_count);

    Ok((build, pattern_sources))
}
